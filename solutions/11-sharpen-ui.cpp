// include aia and ucas utility functions
#include "aiaConfig.h"
#include "ucasConfig.h"

// include my project functions
#include "functions.h"

namespace eiid
{
	// since we work with a GUI, one possible solution to pass parameters
	// to/from the GUI/application core functions is to store parameters 
	// (including images) in global variables
	cv::Mat img;
	int sharpening_factor_x10 = 0;			// sharpening factor x 10 (since OpenCV trackbars support integers only)
	bool use_laplacian_or_unsharp = true;	// whether we use laplacian-based sharpening (true) or unsharp masking (false)

	// NOTE: this is a callback function we will link to the trackbars in the GUI
	//       all trackbar callback functions must have the prototype (int, void*)
	//       see http://docs.opencv.org/2.4/modules/highgui/doc/user_interface.html?highlight=createtrackbar
	void sharpen(int pos, void* userdata) 
	{
		cv::Mat sharpened = img.clone();

		if(use_laplacian_or_unsharp)
		{
			// Laplace filter (2nd order derivatives), invariant to 90° rotations, is
			//
			// 0   1   0
			// 1  -4   1
			// 0   1   0
			//
			// A better, 45° rotation invariant version is given by
			//
			// 1   1   1
			// 1  -8   1
			// 1   1   1
			//
			// In order to sharpen the image f using the Laplacian filter L, we need to calculate
			// fsharp = f - k·f*L,   where '*' denotes convolution, and 'k' is a constant
			// then, applying the associative property of convolution, we can write
			// fsharp = f*LK, where 'LK' is a kernel defined as
			// 
			// 0   0   0        1   1   1      -k  -k  -k
			// 0   1   0  -k·   1  -8   1   =  -k 1+8k -k
			// 0   0   0        1   1   1      -k  -k  -k
			float k = sharpening_factor_x10/10.0f;
			cv::Mat laplacian = (cv::Mat_<float>(3, 3) <<
				-k,  -k,    -k,
				-k, 1+8*k,  -k,
				-k,  -k,    -k);

			
			// if we store the result in a float image and then normalize,
			// the true image content will be compressed in the centermost
			// region of the histogram (=image becomes gray). This is because
			// of the negative (<0) and positive (>255) peaks generated by
			// sharpening at the edges (see lecture slides)
			//cv::filter2D(sharpened, sharpened, CV_32F, laplacian);
			//cv::normalize(sharpened, sharpened, 0, 255, cv::NORM_MINMAX);
			//sharpened.convertTo(sharpened, CV_8U);

			// a better option is to cut the peaks directly by storing
			// the result in 8U
			cv::filter2D(sharpened, sharpened, CV_8U, laplacian);
		}
		else
		{
			// unsharp masking
			cv::Mat smoothed;
			// NOTE: the gaussian filter size/sigma determines the
			// sensibility to the sharpening factor
			// (the higher, the more sensitive to the sharpening factor)
			cv::GaussianBlur(img, smoothed, cv::Size(7,7), 0, 0);
			sharpened = img + (sharpening_factor_x10/10.0)*(img - smoothed);
		}

		// show the result
		cv::imshow("sharpening", sharpened);
	}
}


int main() 
{
	try
	{	
		// load the image
		// try also with "moon.png"
		std::string img_name = "eye.blurry.png";
		eiid::img = cv::imread(std::string(EXAMPLE_IMAGES_PATH) + "/" + img_name, CV_LOAD_IMAGE_UNCHANGED);
		if(!eiid::img.data)
			throw ucas::Error("cannot load image");

		// enable / disable gamma correction
		eiid::use_laplacian_or_unsharp = false;

		// create the window and insert the trackbar
		cv::namedWindow("sharpening");
		cv::createTrackbar("sharpening_factor_x10", "sharpening", &eiid::sharpening_factor_x10, 200, eiid::sharpen);

		// call function with default parameters so it is updated right after the app starts
		eiid::sharpen(0,0);

		// wait for key press = windows stay opened until the user presses any key
		cv::waitKey(0);

		return 1;
	}
	catch (aia::error &ex)
	{
		std::cout << "EXCEPTION thrown by " << ex.getSource() << "source :\n\t|=> " << ex.what() << std::endl;
	}
	catch (ucas::Error &ex)
	{
		std::cout << "EXCEPTION thrown by unknown source :\n\t|=> " << ex.what() << std::endl;
	}
}
